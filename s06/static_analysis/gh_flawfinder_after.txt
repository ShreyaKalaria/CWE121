Flawfinder version 2.0.8, (C) 2001-2017 David A. Wheeler.
Number of rules (primarily dangerous function names) in C/C++ ruleset: 223
decomp/ghidra_decompiled.c:26:  [4] (format) printf:
  If format strings can be influenced by an attacker, they can be exploited
  (CWE-134). Use a constant for the format specification.
int printf(char *__format,...)
decomp/ghidra_decompiled.c:50:  [4] (format) snprintf:
  If format strings can be influenced by an attacker, they can be exploited,
  and note that sprintf variations do not always \0-terminate (CWE-134). Use
  a constant for the format specification.
int snprintf(char *__s,size_t __maxlen,char *__format,...)
decomp/ghidra_decompiled.c:219:  [4] (format) wprintf:
  If format strings can be influenced by an attacker, they can be exploited
  (CWE-134). Use a constant for the format specification.
int wprintf(wchar_t *__format,...)
decomp/ghidra_decompiled.c:50961:  [4] (format) printf:
  If format strings can be influenced by an attacker, they can be exploited
  (CWE-134). Use a constant for the format specification.
  printf((char *)(double)fParm1,&DAT_0044be2d);
decomp/ghidra_decompiled.c:51030:  [4] (format) printf:
  If format strings can be influenced by an attacker, they can be exploited
  (CWE-134). Use a constant for the format specification.
  printf(pcParm1,&DAT_0044be4a);
decomp/ghidra_decompiled.c:239:  [3] (random) srand:
  This function is not sufficiently random for security-related functions
  such as key and nonce creation (CWE-327). Use a more secure technique for
  acquiring random values.
void srand(uint __seed)
decomp/ghidra_decompiled.c:401:  [3] (random) srand:
  This function is not sufficiently random for security-related functions
  such as key and nonce creation (CWE-327). Use a more secure technique for
  acquiring random values.
  srand((uint)tVar1);
decomp/ghidra_decompiled.c:309:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
void * memcpy(void *__dest,void *__src,size_t __n)
decomp/ghidra_decompiled.c:2219:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:2253:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:2287:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:2764:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:2800:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:2834:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:2877:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:2915:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:3393:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:3432:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:3544:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_58,local_18,__n);
decomp/ghidra_decompiled.c:3575:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_58,local_18,__n);
decomp/ghidra_decompiled.c:3956:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:3983:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:4124:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:4164:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:4190:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:4207:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:4224:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:4241:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:4258:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:4275:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:4385:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [112];
decomp/ghidra_decompiled.c:4424:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [112];
decomp/ghidra_decompiled.c:5221:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:5240:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:5257:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:5279:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:5296:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:5315:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:5524:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:5565:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:5604:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:6048:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:6090:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:6130:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:6157:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:6193:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:6232:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:6888:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:6922:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:6963:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:7004:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:7048:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:7555:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:7591:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:7630:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:7765:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:7784:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:7801:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:7823:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:7840:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:7859:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:7929:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:7980:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:8027:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:8071:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:8107:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:8146:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:8225:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:8261:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:8297:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:8888:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:8924:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:8958:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:9174:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:9210:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:9249:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:9586:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,local_10,__n);
decomp/ghidra_decompiled.c:9617:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,local_10,__n);
decomp/ghidra_decompiled.c:10363:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:10390:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:10846:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:10873:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:11737:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:11780:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:11826:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:12389:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:12423:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:12457:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:12775:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,local_10,__n);
decomp/ghidra_decompiled.c:12806:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,local_10,__n);
decomp/ghidra_decompiled.c:13326:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:13362:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:13401:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:13456:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:13483:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:13726:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:13743:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:13760:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:13777:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:14078:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_98 [112];
decomp/ghidra_decompiled.c:14116:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_98 [112];
decomp/ghidra_decompiled.c:14162:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:14196:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:14458:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:14494:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:14533:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:14638:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_98 [104];
decomp/ghidra_decompiled.c:14683:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_98 [104];
decomp/ghidra_decompiled.c:14822:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,local_10,__n);
decomp/ghidra_decompiled.c:14868:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,local_10,__n);
decomp/ghidra_decompiled.c:15076:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:15093:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:15112:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:15129:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:15146:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:15163:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:15595:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:15631:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:15665:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:15707:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_a8 [112];
decomp/ghidra_decompiled.c:15750:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_a8 [112];
decomp/ghidra_decompiled.c:15827:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:15876:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:15919:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:15956:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:16003:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:16676:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack128 + 1,local_30,__n,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:16720:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack128 + 1,local_30,__n,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:16796:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,local_10,__n);
decomp/ghidra_decompiled.c:16825:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,local_10,__n);
decomp/ghidra_decompiled.c:17256:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:17292:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:17331:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:17677:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_98 [112];
decomp/ghidra_decompiled.c:17698:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_d8,local_18,__n);
decomp/ghidra_decompiled.c:17715:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_98 [112];
decomp/ghidra_decompiled.c:17736:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_d8,local_18,__n);
decomp/ghidra_decompiled.c:18166:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:18193:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:18298:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [112];
decomp/ghidra_decompiled.c:18337:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [112];
decomp/ghidra_decompiled.c:18631:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:18665:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:18699:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:18999:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:19033:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:19209:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:19249:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:19738:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:19774:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:19813:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:19907:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:19949:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:20222:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_58,local_18,__n);
decomp/ghidra_decompiled.c:20253:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_58,local_18,__n);
decomp/ghidra_decompiled.c:20287:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:20306:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:20323:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:20345:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:20362:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:20381:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:20445:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_98 [104];
decomp/ghidra_decompiled.c:20471:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_d8,local_28,__n);
decomp/ghidra_decompiled.c:20490:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_98 [104];
decomp/ghidra_decompiled.c:20516:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_d8,local_28,__n);
decomp/ghidra_decompiled.c:20649:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:20683:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:20897:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,local_10,__n);
decomp/ghidra_decompiled.c:20926:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,local_10,__n);
decomp/ghidra_decompiled.c:21046:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:21084:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:21125:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:21171:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:21205:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:21239:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:21345:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:21386:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:21430:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:21765:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:21782:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:21801:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:21818:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:21835:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:21852:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:21878:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:21899:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_c8,local_20,__n);
decomp/ghidra_decompiled.c:21916:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:21937:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_c8,local_20,__n);
decomp/ghidra_decompiled.c:21962:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:21998:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:22037:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:22205:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:22239:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:22487:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:22523:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:22557:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:22600:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:22636:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:22670:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:23430:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_a8 [104];
decomp/ghidra_decompiled.c:23480:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_a8 [104];
decomp/ghidra_decompiled.c:23552:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:23590:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:23631:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:23945:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:23986:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:24025:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:24155:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack144 + 1,local_40,__n,*(undefined *)(auStack144 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:24206:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack144 + 1,local_40,__n,*(undefined *)(auStack144 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:24313:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:24340:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:24385:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,local_10,__n);
decomp/ghidra_decompiled.c:24414:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,local_10,__n);
decomp/ghidra_decompiled.c:24568:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_98 [104];
decomp/ghidra_decompiled.c:24611:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_98 [104];
decomp/ghidra_decompiled.c:25088:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_98 [112];
decomp/ghidra_decompiled.c:25126:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_98 [112];
decomp/ghidra_decompiled.c:25242:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:25284:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:25324:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:25377:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack128 + 1,local_38,__n,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:25421:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack128 + 1,local_38,__n,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:25591:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [112];
decomp/ghidra_decompiled.c:25630:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [112];
decomp/ghidra_decompiled.c:25787:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:25823:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:25862:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:26388:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:26436:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:26481:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:26788:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:26805:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:26822:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:26839:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:27577:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:27621:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:27665:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:27810:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:27846:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:27885:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:27929:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:27970:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:28014:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:28188:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:28224:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:28263:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:28643:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:28663:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:28681:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:28704:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:28722:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:28742:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:28768:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:28785:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:28802:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:28819:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:28836:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:28853:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:28904:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:28953:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:28996:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:29447:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:29486:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:29525:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:30017:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:30034:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:30051:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:30068:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:30305:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:30332:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:30439:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30495:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30548:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30597:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30637:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30677:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30965:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:31012:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:31397:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:31417:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:31435:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:31458:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:31476:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:31496:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:31659:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:31711:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:31848:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:31891:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:31937:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:31988:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:32027:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:32066:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:32661:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:32702:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:32746:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:32827:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:32878:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:32925:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:32974:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:33014:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:33054:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:33428:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:33467:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:33579:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:33613:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:33647:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:33715:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:33764:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:33807:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:33896:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:33930:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:34538:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:34577:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:34647:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:34687:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:34739:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:34766:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:35004:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:35028:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:35046:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:35070:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:35095:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:35131:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:35170:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:35726:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:35762:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:35801:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:35894:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:35930:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:35969:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:36347:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,local_10,__n);
decomp/ghidra_decompiled.c:36376:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,local_10,__n);
decomp/ghidra_decompiled.c:36561:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:36610:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:36653:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:36986:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:37022:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:37056:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:37099:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:37137:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:37596:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,local_10,__n);
decomp/ghidra_decompiled.c:37648:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,local_10,__n);
decomp/ghidra_decompiled.c:38429:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:38463:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:38497:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:38784:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:38818:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:38852:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:39005:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [112];
decomp/ghidra_decompiled.c:39027:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_c8,local_18,__n);
decomp/ghidra_decompiled.c:39044:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [112];
decomp/ghidra_decompiled.c:39066:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_c8,local_18,__n);
decomp/ghidra_decompiled.c:39163:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:39206:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:39373:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:39392:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:39409:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:39431:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:39448:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:39467:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:39665:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,local_10,__n);
decomp/ghidra_decompiled.c:39694:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,local_10,__n);
decomp/ghidra_decompiled.c:40501:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:40528:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:40778:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_98 [112];
decomp/ghidra_decompiled.c:40816:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_98 [112];
decomp/ghidra_decompiled.c:40879:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:40914:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:41207:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:41226:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:41243:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:41265:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:41282:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:41301:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:41328:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:41370:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:41520:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_98 [112];
decomp/ghidra_decompiled.c:41564:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_98 [112];
decomp/ghidra_decompiled.c:41617:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:41653:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:41692:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:41738:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:41780:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:42196:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42245:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42288:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42539:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_30,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42584:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_30,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42933:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:42982:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:43029:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:43065:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:43104:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:43264:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:43302:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:43343:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:43389:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:43423:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:43457:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:43515:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:43553:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:43594:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:44015:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:44049:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:44083:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:44627:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:44661:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:44702:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:44743:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:44787:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:44923:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:44961:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:45002:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:45170:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:45213:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:45426:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:45475:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:45518:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:45666:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:45704:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:45745:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:46596:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:46613:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:46630:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:46647:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:46664:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:46681:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:47105:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:47147:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:47190:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:47226:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:47265:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:47669:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:47703:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:48028:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:48047:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:48064:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:48086:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:48103:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:48122:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:48260:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:48301:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:48603:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_98 [104];
decomp/ghidra_decompiled.c:48648:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_98 [104];
decomp/ghidra_decompiled.c:48867:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,local_10,__n);
decomp/ghidra_decompiled.c:48896:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,local_10,__n);
decomp/ghidra_decompiled.c:49288:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_98 [104];
decomp/ghidra_decompiled.c:49333:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_98 [104];
decomp/ghidra_decompiled.c:49575:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:49614:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:49653:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:49871:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:49905:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_78 [104];
decomp/ghidra_decompiled.c:49997:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:50035:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:50193:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:50220:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:50364:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:50404:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:50444:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:50632:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:50682:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:50796:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:50837:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:50881:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_88 [104];
decomp/ghidra_decompiled.c:62:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
char * strncat(char *__dest,char *__src,size_t __n)
decomp/ghidra_decompiled.c:148:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
size_t strlen(char *__s)
decomp/ghidra_decompiled.c:249:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
char * strncpy(char *__dest,char *__src,size_t __n)
decomp/ghidra_decompiled.c:2110:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:2150:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:2190:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:2235:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:2269:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:2303:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:2363:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:2417:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:2468:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:2515:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:2553:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:2591:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:2686:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:2736:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:2780:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:2781:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:2816:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:2817:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:2850:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:2851:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:2897:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:2898:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_c8,local_20,__n);
decomp/ghidra_decompiled.c:2935:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:2936:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_c8,local_20,__n);
decomp/ghidra_decompiled.c:2980:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:3018:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:3107:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:3139:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:3171:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:3203:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:3285:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:3287:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:3325:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:3327:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:3365:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:3367:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:3411:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:3450:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:3543:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:3574:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:3660:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:3710:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:3808:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:3857:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:3900:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:3955:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:3982:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:4009:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:4056:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:4122:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:4162:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:4206:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:4240:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:4274:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:4406:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:4407:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_c8,local_18,__n);
decomp/ghidra_decompiled.c:4445:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:4446:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_c8,local_18,__n);
decomp/ghidra_decompiled.c:4495:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:4539:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:4624:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:4625:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:4667:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:4668:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:4720:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:4749:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:4866:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:4915:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:4960:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:5007:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:5045:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:5083:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:5125:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(__s);
decomp/ghidra_decompiled.c:5176:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(__s);
decomp/ghidra_decompiled.c:5239:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:5278:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:5314:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:5352:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:5353:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:5381:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:5382:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:5446:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_40,*(undefined *)(auStack144 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:5448:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack144 + 1,local_40,__n,*(undefined *)(auStack144 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:5497:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_40,*(undefined *)(auStack144 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:5499:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack144 + 1,local_40,__n,*(undefined *)(auStack144 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:5542:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:5583:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:5622:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:5693:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:5740:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:5781:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:5852:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:5853:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:5881:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:5882:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:5925:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:5952:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:6046:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:6088:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:6128:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:6175:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:6176:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:6214:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:6215:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:6250:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:6251:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:6285:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(pcParm1);
decomp/ghidra_decompiled.c:6310:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(pcParm1);
decomp/ghidra_decompiled.c:6349:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:6396:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:6437:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:6533:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:6535:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:6575:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:6577:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:6615:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:6617:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:6668:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:6670:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack128 + 1,local_38,__n,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:6712:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:6714:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack128 + 1,local_38,__n,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:6756:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:6757:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:6790:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:6791:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:6830:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen(local_20);
decomp/ghidra_decompiled.c:6866:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen(local_20);
decomp/ghidra_decompiled.c:6904:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:6905:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:6938:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:6939:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:6983:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:7027:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:7068:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:7267:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:7323:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:7367:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:7368:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:7398:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:7399:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:7432:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:7467:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:7506:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:7507:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_58,local_18,__n);
decomp/ghidra_decompiled.c:7537:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:7538:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_58,local_18,__n);
decomp/ghidra_decompiled.c:7573:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:7574:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:7612:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:7613:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:7648:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:7649:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:7684:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:7685:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:7725:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:7726:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:7783:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:7822:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:7858:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:7927:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:7978:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:8025:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:8089:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:8128:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:8164:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:8224:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:8260:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:8296:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:8334:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:8335:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:8363:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:8364:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:8410:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:8465:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:8516:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:8569:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:8613:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:8657:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:8784:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:8785:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:8830:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:8831:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:8904:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:8905:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:8940:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:8941:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:8974:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:8975:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:9042:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:9095:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:9142:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:9192:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:9193:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:9231:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:9232:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:9267:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:9268:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:9303:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:9352:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:9440:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:9493:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:9540:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:9585:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:9616:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:9675:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:9677:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:9719:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:9721:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:9763:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:9765:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:9801:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:9802:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:9828:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:9829:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:9867:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:9911:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:9994:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:10026:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:10098:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:10100:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:10148:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:10150:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:10234:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:10266:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:10362:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:10389:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:10465:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:10467:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:10505:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:10507:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:10576:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:10631:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:10682:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:10744:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_40,*(undefined *)(auStack144 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:10793:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_40,*(undefined *)(auStack144 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:10845:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:10872:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:10914:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:10957:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:11008:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:11010:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:11057:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:11059:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:11100:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:11102:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:11139:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(pcParm1);
decomp/ghidra_decompiled.c:11166:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(pcParm1);
decomp/ghidra_decompiled.c:11228:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:11229:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:11275:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:11276:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:11437:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:11486:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:11529:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:11651:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:11653:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack128 + 1,local_30,__n,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:11695:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:11697:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack128 + 1,local_30,__n,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:11758:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:11804:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:11847:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:11897:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:11937:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:11975:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:12026:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:12068:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:12106:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:12107:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:12135:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:12136:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:12219:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(__s);
decomp/ghidra_decompiled.c:12255:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(__s);
decomp/ghidra_decompiled.c:12290:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:12291:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:12342:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:12343:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:12405:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:12439:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:12473:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:12520:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:12522:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:12562:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:12564:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:12602:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:12604:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:12655:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:12697:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:12774:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:12805:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:12896:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:12897:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:12923:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:12924:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:13007:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:13039:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:13110:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:13139:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:13219:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:13251:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:13344:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:13383:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:13419:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:13455:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:13482:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:13509:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:13550:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:13614:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:13656:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:13698:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:13742:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:13776:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:13824:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:13871:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:13912:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:14098:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:14136:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:14178:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:14212:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:14258:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:14298:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:14476:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:14477:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:14515:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:14516:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:14551:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:14552:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:14589:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:14590:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:14618:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:14619:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:14663:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28);
decomp/ghidra_decompiled.c:14664:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_d8,local_28,__n);
decomp/ghidra_decompiled.c:14708:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28);
decomp/ghidra_decompiled.c:14709:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_d8,local_28,__n);
decomp/ghidra_decompiled.c:14761:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:14762:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:14790:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:14791:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:14821:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:14867:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:14922:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(__s);
decomp/ghidra_decompiled.c:14958:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(__s);
decomp/ghidra_decompiled.c:14989:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:15016:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:15092:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:15128:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:15162:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:15199:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:15245:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:15302:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:15333:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:15364:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:15365:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:15410:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:15411:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:15474:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:15476:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:15523:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:15525:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:15566:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:15568:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:15611:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:15612:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:15647:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:15648:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:15681:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:15682:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:15729:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen(local_18);
decomp/ghidra_decompiled.c:15772:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen(local_18);
decomp/ghidra_decompiled.c:15825:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:15874:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:15917:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:15955:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:16002:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:16076:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:16110:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:16197:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:16198:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:16232:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:16233:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:16267:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:16268:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:16365:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:16367:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:16414:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:16416:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:16457:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:16459:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:16495:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:16522:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:16571:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_40,*(undefined *)(auStack144 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:16573:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack144 + 1,local_40,__n,*(undefined *)(auStack144 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:16622:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_40,*(undefined *)(auStack144 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:16624:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack144 + 1,local_40,__n,*(undefined *)(auStack144 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:16674:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:16718:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:16795:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:16824:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:16867:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:16894:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:16923:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:16924:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:16952:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:16953:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:16991:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:17035:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:17160:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:17192:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:17274:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:17275:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:17313:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:17314:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:17349:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:17350:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:17397:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:17441:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:17485:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:17537:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:17539:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:17577:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:17579:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:17615:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_10);
decomp/ghidra_decompiled.c:17643:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_10);
decomp/ghidra_decompiled.c:17697:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:17735:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:17781:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:17783:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:17823:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:17825:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:17863:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:17865:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:17916:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:17918:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack128 + 1,local_38,__n,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:17960:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:17962:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack128 + 1,local_38,__n,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:18019:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen(local_20,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:18073:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen(local_20,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:18165:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:18192:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:18319:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:18358:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:18511:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:18512:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:18559:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:18560:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:18604:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:18605:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:18647:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:18648:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:18681:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:18682:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:18715:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:18716:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:18867:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:18920:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:18967:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:19015:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:19016:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:19049:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:19050:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:19085:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:19137:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:19207:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:19247:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:19288:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:19319:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:19350:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:19351:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:19402:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:19403:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:19469:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:19471:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:19511:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:19513:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:19551:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:19553:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:19589:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:19590:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:19616:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:19617:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:19659:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(local_30,*(undefined *)(auStack144 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:19707:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(local_30,*(undefined *)(auStack144 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:19756:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:19757:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:19795:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:19796:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:19831:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:19832:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:19930:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:19931:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:19972:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:19973:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:20010:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:20044:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:20091:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:20093:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:20135:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:20137:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:20179:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:20181:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:20221:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:20252:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:20305:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:20344:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:20380:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:20470:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28);
decomp/ghidra_decompiled.c:20515:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28);
decomp/ghidra_decompiled.c:20550:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:20577:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:20604:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:20631:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:20665:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:20699:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:20799:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_30,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:20842:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_30,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:20896:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:20925:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:20951:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(pcParm1);
decomp/ghidra_decompiled.c:20998:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(pcParm1);
decomp/ghidra_decompiled.c:21065:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:21066:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:21106:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:21107:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:21144:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:21145:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:21187:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:21188:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:21221:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:21222:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:21255:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:21256:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:21292:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:21324:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:21365:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:21409:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:21450:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:21560:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:21562:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:21609:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:21611:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:21652:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:21654:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:21781:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:21817:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:21851:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:21898:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:21936:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:21980:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:21981:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:22019:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:22020:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:22055:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:22056:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:22221:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:22222:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:22255:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:22256:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:22294:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:22340:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:22440:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:22441:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:22469:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:22470:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:22503:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:22539:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:22573:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:22616:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:22617:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:22652:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:22653:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:22686:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:22687:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:22747:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:22749:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:22803:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:22805:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:22856:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:22858:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:22905:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:22907:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:22945:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:22947:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:22985:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:22987:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:23092:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:23133:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:23180:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:23182:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:23220:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:23222:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:23268:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:23310:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:23350:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:23387:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(pcParm1);
decomp/ghidra_decompiled.c:23412:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(pcParm1);
decomp/ghidra_decompiled.c:23457:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30);
decomp/ghidra_decompiled.c:23507:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30);
decomp/ghidra_decompiled.c:23571:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:23572:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:23612:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:23613:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:23650:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:23651:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:23699:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:23746:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:23787:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:23828:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:23860:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:23890:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(pcParm1);
decomp/ghidra_decompiled.c:23924:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(pcParm1);
decomp/ghidra_decompiled.c:23963:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:24004:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:24043:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:24153:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_40,*(undefined *)(auStack144 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:24204:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_40,*(undefined *)(auStack144 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:24241:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:24268:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:24312:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:24339:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:24384:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:24413:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:24453:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:24500:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:24541:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:24590:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_30 = strlen(local_18);
decomp/ghidra_decompiled.c:24633:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_30 = strlen(local_18);
decomp/ghidra_decompiled.c:24686:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:24688:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:24735:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:24737:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:24778:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:24780:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:24827:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:24829:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:24867:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:24869:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:24907:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:24909:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:24988:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:24989:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:25022:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:25023:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:25108:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:25109:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_d8,local_18,__n);
decomp/ghidra_decompiled.c:25146:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:25147:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_d8,local_18,__n);
decomp/ghidra_decompiled.c:25240:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:25282:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:25322:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:25375:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:25419:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:25470:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:25472:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:25519:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:25521:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:25562:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:25564:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:25612:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:25613:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_c8,local_18,__n);
decomp/ghidra_decompiled.c:25651:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:25652:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_c8,local_18,__n);
decomp/ghidra_decompiled.c:25686:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:25687:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:25729:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:25730:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:25805:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:25844:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:25880:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:25968:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:25969:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:25995:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:25996:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:26033:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:26035:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:26073:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:26075:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:26128:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:26176:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:26221:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:26261:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:26313:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:26387:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:26435:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:26480:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:26518:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:26519:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:26547:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:26548:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:26585:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:26627:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:26667:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:26804:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:26838:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:26873:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:26874:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:26900:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:26901:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:26938:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:26940:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:26978:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:26980:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:27024:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:27064:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:27104:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:27159:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:27212:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:27259:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:27323:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_50 = strlen(local_48,*(undefined *)(auStack160 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:27378:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_50 = strlen(local_48,*(undefined *)(auStack160 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:27456:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:27458:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:27506:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:27508:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:27575:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:27619:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:27663:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:27705:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:27736:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:27828:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:27867:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:27903:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:27949:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:27993:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:28034:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:28084:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:28122:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:28160:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:28206:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:28207:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:28245:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:28246:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:28281:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:28282:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:28317:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:28318:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:28344:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:28345:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:28416:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:28462:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:28506:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:28563:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_48 = strlen(local_30,*(undefined *)(auStack144 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:28611:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_48 = strlen(local_30,*(undefined *)(auStack144 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:28662:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:28703:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:28741:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:28784:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:28818:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:28852:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:28902:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:28951:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:28994:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:29083:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:29117:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:29202:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:29232:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:29314:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:29367:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:29417:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:29465:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:29504:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:29543:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:29599:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_30,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:29601:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_30,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:29644:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_30,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:29646:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_30,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:29717:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:29718:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:29766:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:29767:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:29901:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:29948:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:29989:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30033:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:30067:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:30117:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(pcParm1);
decomp/ghidra_decompiled.c:30162:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(pcParm1);
decomp/ghidra_decompiled.c:30227:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30267:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30304:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:30331:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:30358:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:30359:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:30385:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:30386:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:30437:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30493:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30546:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30595:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30635:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30675:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30793:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30795:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30845:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30847:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30896:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30938:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:30990:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:31037:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:31076:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:31077:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:31103:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:31104:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:31130:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:31131:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:31157:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:31158:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:31185:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_10);
decomp/ghidra_decompiled.c:31212:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_10);
decomp/ghidra_decompiled.c:31254:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen(local_20,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:31302:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen(local_20,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:31350:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen(local_20,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:31416:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:31457:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:31495:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:31582:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(pcParm1);
decomp/ghidra_decompiled.c:31607:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(pcParm1);
decomp/ghidra_decompiled.c:31657:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:31709:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:31777:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:31779:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:31820:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:31822:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:31869:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:31915:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:31958:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:32006:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:32045:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:32084:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:32129:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(__s);
decomp/ghidra_decompiled.c:32186:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(__s);
decomp/ghidra_decompiled.c:32313:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:32366:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:32413:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:32524:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:32526:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:32573:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:32575:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:32616:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:32618:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:32681:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:32725:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:32766:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:32825:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:32876:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:32923:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:32972:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:33012:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:33052:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:33090:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:33133:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:33214:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:33216:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:33263:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:33265:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:33306:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:33308:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:33380:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:33381:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:33411:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:33412:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:33446:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:33485:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:33525:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:33557:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:33595:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:33596:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:33629:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:33630:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:33663:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:33664:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:33713:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:33762:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:33805:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:33847:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:33848:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_58,local_18,__n);
decomp/ghidra_decompiled.c:33878:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:33879:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_58,local_18,__n);
decomp/ghidra_decompiled.c:33912:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:33946:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:34006:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen(local_20,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:34066:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen(local_20,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:34123:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen(local_20,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:34176:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:34220:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:34264:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:34339:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:34340:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:34381:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:34382:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:34464:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:34508:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:34556:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:34595:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:34645:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:34685:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:34738:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:34765:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:34792:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:34793:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:34819:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:34820:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:34846:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:34847:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:34873:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:34874:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:34949:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:34981:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:35027:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:35069:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:35113:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:35114:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:35152:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:35153:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:35188:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:35189:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:35256:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:35305:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:35350:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:35405:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:35406:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:35453:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:35454:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:35498:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:35499:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:35581:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:35621:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:35661:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:35744:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:35783:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:35819:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:35912:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:35913:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:35951:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:35952:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:35987:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:35988:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:36040:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:36041:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:36089:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:36090:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:36162:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_30,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:36207:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_30,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:36346:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:36375:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:36414:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:36460:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:36504:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:36559:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:36608:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:36651:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:36693:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:36694:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:36724:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:36725:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:36751:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:36752:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:36778:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:36779:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:36848:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:36904:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:36957:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:37002:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:37038:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:37072:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:37119:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:37157:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:37268:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:37269:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:37295:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:37296:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:37375:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:37377:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:37418:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:37420:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:37460:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen(local_20);
decomp/ghidra_decompiled.c:37496:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen(local_20);
decomp/ghidra_decompiled.c:37595:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:37647:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:37703:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:37704:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:37730:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:37731:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:37782:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:37784:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:37838:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:37840:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:37891:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:37893:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:37940:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:37942:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:37980:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:37982:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:38020:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:38022:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:38072:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:38121:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:38164:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:38212:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:38250:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:38330:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:38366:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:38402:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:38445:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:38446:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:38479:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:38480:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:38513:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:38514:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:38663:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:38712:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:38755:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:38800:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:38801:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:38834:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:38835:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:38868:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:38869:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:38926:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_40,*(undefined *)(auStack144 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:38977:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_40,*(undefined *)(auStack144 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:39026:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:39065:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:39104:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:39105:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_58,local_18,__n);
decomp/ghidra_decompiled.c:39135:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:39136:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_58,local_18,__n);
decomp/ghidra_decompiled.c:39162:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:39205:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:39271:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:39272:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:39313:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:39314:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:39391:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:39430:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:39466:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:39552:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:39581:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:39608:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:39635:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:39664:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:39693:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:39723:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(__s);
decomp/ghidra_decompiled.c:39752:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(__s);
decomp/ghidra_decompiled.c:39829:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:39873:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:39996:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:39998:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:40045:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:40047:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:40088:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:40090:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:40145:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:40147:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:40196:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:40198:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:40243:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:40245:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:40292:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:40294:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:40332:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:40334:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:40372:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:40374:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:40410:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:40411:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:40451:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:40452:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:40500:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:40527:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:40622:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(pcParm1);
decomp/ghidra_decompiled.c:40647:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(pcParm1);
decomp/ghidra_decompiled.c:40798:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:40799:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_d8,local_18,__n);
decomp/ghidra_decompiled.c:40836:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:40837:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_d8,local_18,__n);
decomp/ghidra_decompiled.c:40878:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:40913:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:40988:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:40989:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:41017:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:41018:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:41139:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:41141:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:41179:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:41181:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:41225:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:41264:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:41300:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:41351:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:41352:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:41393:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:41394:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:41428:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:41429:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:41455:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:41456:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:41543:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen(local_20);
decomp/ghidra_decompiled.c:41587:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen(local_20);
decomp/ghidra_decompiled.c:41635:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:41636:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:41674:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:41675:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:41710:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:41711:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:41761:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:41803:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:41839:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:41887:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:41942:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:41943:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:41969:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:41970:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:42012:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42056:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42100:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42194:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42243:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42286:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42335:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42337:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42375:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42377:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42415:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42417:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42456:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:42490:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:42537:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_30,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42582:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_30,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42652:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42654:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42703:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42705:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42750:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42752:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42802:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42851:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42894:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:42932:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:42981:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:43047:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:43086:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:43122:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:43197:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:43198:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_58,local_18,__n);
decomp/ghidra_decompiled.c:43228:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_18);
decomp/ghidra_decompiled.c:43229:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_58,local_18,__n);
decomp/ghidra_decompiled.c:43283:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:43324:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:43362:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:43405:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:43439:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:43473:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:43534:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:43535:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:43575:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:43576:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:43613:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:43614:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:43703:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:43752:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:43795:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:43849:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_30,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:43851:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_30,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:43894:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_30,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:43896:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_30,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:43952:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:43981:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:44031:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:44032:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:44065:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:44066:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:44099:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:44100:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:44143:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:44182:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:44235:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:44237:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:44284:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:44286:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:44327:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:44329:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:44365:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:44366:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:44412:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:44413:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:44531:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(pcParm1);
decomp/ghidra_decompiled.c:44556:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(pcParm1);
decomp/ghidra_decompiled.c:44582:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:44609:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:44643:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:44644:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:44677:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:44678:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:44722:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:44766:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:44807:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:44857:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:44895:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:44942:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:44943:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:44983:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:44984:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:45021:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:45022:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:45072:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:45074:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack128 + 1,local_30,__n,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:45116:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:45118:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack128 + 1,local_30,__n,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:45168:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:45211:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:45250:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:45251:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:45279:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:45280:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:45317:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:45357:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:45424:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:45473:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:45516:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:45554:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:45555:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:45581:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:45582:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:45685:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:45726:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:45764:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:45959:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(local_38,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:46008:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(local_38,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:46072:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:46074:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:46124:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:46126:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:46185:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:46237:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:46275:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:46329:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen(pcParm1);
decomp/ghidra_decompiled.c:46390:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:46391:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:46417:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:46418:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:46475:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:46477:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:46524:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:46526:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:46567:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:46569:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:46612:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:46646:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:46680:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:46775:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(__s);
decomp/ghidra_decompiled.c:46825:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(__s);
decomp/ghidra_decompiled.c:46883:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(pcParm1);
decomp/ghidra_decompiled.c:46917:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(pcParm1);
decomp/ghidra_decompiled.c:46974:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:47014:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:47052:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:47104:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:47146:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:47208:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:47209:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:47247:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:47248:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:47283:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:47284:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:47338:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:47367:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:47413:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:47464:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:47511:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:47560:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:47600:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:47640:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:47685:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:47686:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:47719:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:47720:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:47787:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:47789:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:47838:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:47840:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:47885:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:47887:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:47931:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:47932:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:47966:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:47967:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:48001:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:48002:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:48046:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:48085:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:48121:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:48172:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen(local_20,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:48219:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen(local_20,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:48259:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:48300:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:48368:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_18);
decomp/ghidra_decompiled.c:48398:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_18);
decomp/ghidra_decompiled.c:48498:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:48499:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:48529:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(__s);
decomp/ghidra_decompiled.c:48530:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:48556:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:48583:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:48628:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28);
decomp/ghidra_decompiled.c:48629:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_d8,local_28,__n);
decomp/ghidra_decompiled.c:48673:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28);
decomp/ghidra_decompiled.c:48674:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_d8,local_28,__n);
decomp/ghidra_decompiled.c:48723:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:48776:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:48823:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen(local_30,*(undefined *)(auStack128 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:48866:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:48895:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:48941:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:48943:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:48992:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:48994:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:49039:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:49041:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:49079:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:49080:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:49108:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:49109:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_48,local_10,__n);
decomp/ghidra_decompiled.c:49149:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:49151:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:49198:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:49200:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:49241:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:49243:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(auStack112 + 1,local_28,__n,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:49313:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28);
decomp/ghidra_decompiled.c:49358:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28);
decomp/ghidra_decompiled.c:49477:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:49478:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:49504:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:49505:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:49531:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:49532:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:49558:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:49559:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_48,pcParm1,__n);
decomp/ghidra_decompiled.c:49593:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:49632:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:49671:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:49744:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:49795:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:49842:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar3 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:49887:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:49888:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:49921:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:49922:  [1] (buffer) strncat:
  Easily used incorrectly (e.g., incorrectly computing the correct maximum
  size to add) [MS-banned] (CWE-120). Consider strcat_s, strlcat, snprintf,
  or automatically resizing strings.
  strncat((char *)&local_b8,local_10,__n);
decomp/ghidra_decompiled.c:50017:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:50018:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_c8,local_20,__n);
decomp/ghidra_decompiled.c:50055:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_10);
decomp/ghidra_decompiled.c:50056:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy((char *)&local_c8,local_20,__n);
decomp/ghidra_decompiled.c:50106:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:50153:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:50192:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:50219:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(pcParm1);
decomp/ghidra_decompiled.c:50267:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:50315:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __maxlen = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:50362:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:50402:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:50442:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar1 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:50630:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:50680:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  __n = strlen(local_28,*(undefined *)(auStack112 + lVar2 * 0x1ffffffffffffffe));
decomp/ghidra_decompiled.c:50816:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:50860:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);
decomp/ghidra_decompiled.c:50901:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen(local_18);

ANALYSIS SUMMARY:

Hits = 1833
Lines analyzed = 51402 in approximately 2.21 seconds (23211 lines/second)
Physical Source Lines of Code (SLOC) = 43772
Hits@level = [0] 103 [1] 1368 [2] 458 [3]   2 [4]   5 [5]   0
Hits@level+ = [0+] 1936 [1+] 1833 [2+] 465 [3+]   7 [4+]   5 [5+]   0
Hits/KSLOC@level+ = [0+] 44.2292 [1+] 41.8761 [2+] 10.6232 [3+] 0.15992 [4+] 0.114228 [5+]   0
Minimum risk level = 1
Not every hit is necessarily a security vulnerability.
There may be other security vulnerabilities; review your code!
See 'Secure Programming HOWTO'
(https://dwheeler.com/secure-programs) for more information.
