Flawfinder version 2.0.8, (C) 2001-2017 David A. Wheeler.
Number of rules (primarily dangerous function names) in C/C++ ruleset: 223
decomp/Decompiled.c:26:  [4] (format) printf:
  If format strings can be influenced by an attacker, they can be exploited
  (CWE-134). Use a constant for the format specification.
int printf(char *__format,...)
decomp/Decompiled.c:183:  [4] (format) wprintf:
  If format strings can be influenced by an attacker, they can be exploited
  (CWE-134). Use a constant for the format specification.
int wprintf(wchar_t *__format,...)
decomp/Decompiled.c:203:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
char * strcpy(char *__dest,char *__src)
decomp/Decompiled.c:1703:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_28,(char *)&local_68);
decomp/Decompiled.c:1731:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_28,(char *)&local_68);
decomp/Decompiled.c:2197:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:2217:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:2237:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:2909:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/Decompiled.c:2938:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/Decompiled.c:3888:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:3908:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:5107:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_68_badData,(char *)&local_28);
decomp/Decompiled.c:5125:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_68_goodG2BData,
decomp/Decompiled.c:5354:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_18,(char *)&local_48);
decomp/Decompiled.c:5379:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_18,(char *)&local_48);
decomp/Decompiled.c:5913:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/Decompiled.c:5945:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/Decompiled.c:6686:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:6711:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:6733:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:7589:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:7614:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:7636:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:9325:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/Decompiled.c:9341:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/Decompiled.c:11319:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/Decompiled.c:11335:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/Decompiled.c:11900:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_28);
decomp/Decompiled.c:11918:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_28);
decomp/Decompiled.c:11957:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:11982:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:12004:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:13973:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:13993:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:14956:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_45_badData,(char *)&local_28);
decomp/Decompiled.c:14988:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_45_goodG2BData,
decomp/Decompiled.c:15121:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:15143:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:15163:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:15755:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/Decompiled.c:15771:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/Decompiled.c:15842:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_18,(char *)&local_28);
decomp/Decompiled.c:15862:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_18,(char *)&local_28);
decomp/Decompiled.c:18109:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_28);
decomp/Decompiled.c:18127:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_28);
decomp/Decompiled.c:18534:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/Decompiled.c:18550:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/Decompiled.c:21965:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_28);
decomp/Decompiled.c:21983:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_28);
decomp/Decompiled.c:22201:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:22226:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:22248:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:22317:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:22339:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:22359:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:22392:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_20,(char *)&local_58);
decomp/Decompiled.c:22416:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_20,(char *)&local_58);
decomp/Decompiled.c:23500:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_28,(char *)&local_58);
decomp/Decompiled.c:23524:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_28,(char *)&local_58);
decomp/Decompiled.c:24113:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:24138:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:24160:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:24728:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:24748:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:24768:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:25706:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:25727:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:26458:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:26485:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:26509:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:26538:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:26558:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:26578:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:27021:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:27046:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:27068:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:27290:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:27310:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:27334:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/Decompiled.c:27350:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/Decompiled.c:28127:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:28154:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:28178:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/Decompiled.c:29742:  [4] (format) printf:
  If format strings can be influenced by an attacker, they can be exploited
  (CWE-134). Use a constant for the format specification.
  printf((char *)(double)fParm1,&DAT_00431ac1);
decomp/Decompiled.c:29811:  [4] (format) printf:
  If format strings can be influenced by an attacker, they can be exploited
  (CWE-134). Use a constant for the format specification.
  printf(pcParm1,&DAT_00431ade);
decomp/Decompiled.c:215:  [3] (random) srand:
  This function is not sufficiently random for security-related functions
  such as key and nonce creation (CWE-327). Use a more secure technique for
  acquiring random values.
void srand(uint __seed)
decomp/Decompiled.c:377:  [3] (random) srand:
  This function is not sufficiently random for security-related functions
  such as key and nonce creation (CWE-327). Use a more secure technique for
  acquiring random values.
  srand((uint)tVar1);
decomp/Decompiled.c:285:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
void * memcpy(void *__dest,void *__src,size_t __n)
decomp/Decompiled.c:1687:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_48 [24];
decomp/Decompiled.c:1715:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_58 [40];
decomp/Decompiled.c:1759:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/Decompiled.c:1779:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/Decompiled.c:2132:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:2167:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:2189:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:2209:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:2229:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:2259:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:2283:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:2310:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:2471:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:2495:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:2522:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:2609:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [16];
decomp/Decompiled.c:2635:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_48 [32];
decomp/Decompiled.c:2678:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_18,&local_28,sVar1 + 1);
decomp/Decompiled.c:2700:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_18,&local_28,sVar1 + 1);
decomp/Decompiled.c:2833:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:2860:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:2884:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:3380:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_28,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:3420:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_28,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:3448:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:3489:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:3880:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:3900:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:4272:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:4290:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:4572:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:4606:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:4676:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [16];
decomp/Decompiled.c:4703:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [32];
decomp/Decompiled.c:5255:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/Decompiled.c:5298:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/Decompiled.c:5341:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [16];
decomp/Decompiled.c:5366:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [32];
decomp/Decompiled.c:5679:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:5716:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:5751:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:6192:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:6214:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:6236:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:6454:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:6478:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:6505:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:6676:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:6698:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:6723:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:7579:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:7601:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:7626:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:7958:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:7985:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:8009:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:8840:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_18,&local_48,sVar1 + 1);
decomp/Decompiled.c:8867:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_18,&local_48,sVar1 + 1);
decomp/Decompiled.c:9138:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar2 + 1);
decomp/Decompiled.c:9161:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:9617:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar2 + 1);
decomp/Decompiled.c:9646:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar2 + 1);
decomp/Decompiled.c:9672:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar2 + 1);
decomp/Decompiled.c:9703:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:9725:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:9747:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:9807:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:9850:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/Decompiled.c:9887:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:9976:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:10003:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:10027:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:10433:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:10455:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:10497:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:10515:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:10584:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:10619:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:10654:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:10753:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:10771:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:11026:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:11053:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:11077:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:11216:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/Decompiled.c:11261:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/Decompiled.c:11947:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:11969:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:11994:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:12115:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/Decompiled.c:12161:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/Decompiled.c:12203:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/Decompiled.c:12247:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:12282:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:12317:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:12601:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:12644:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/Decompiled.c:12681:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:12848:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:12883:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:13194:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:13216:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:13891:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:13913:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:13935:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:13965:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:13985:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:14359:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:14383:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:14405:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:14738:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/Decompiled.c:14758:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/Decompiled.c:15113:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:15135:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:15155:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:15224:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:15242:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:15622:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:15657:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:15692:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:16269:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar2 + 1);
decomp/Decompiled.c:16298:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar2 + 1);
decomp/Decompiled.c:16324:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar2 + 1);
decomp/Decompiled.c:16351:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:16369:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:16387:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:16405:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:16423:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:16441:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:16461:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/Decompiled.c:16481:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/Decompiled.c:16886:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:16908:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:16992:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/Decompiled.c:17012:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/Decompiled.c:17654:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/Decompiled.c:17688:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/Decompiled.c:17736:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_18,&local_58,sVar1 + 1);
decomp/Decompiled.c:17762:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_18,&local_58,sVar1 + 1);
decomp/Decompiled.c:18276:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:18300:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:18322:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:18751:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:18794:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/Decompiled.c:18831:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:19668:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/Decompiled.c:19714:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/Decompiled.c:19756:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/Decompiled.c:20504:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:20535:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:20690:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:20714:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:20736:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:20758:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:20782:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:20809:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:20900:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:20943:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/Decompiled.c:20980:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:21004:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_48 [24];
decomp/Decompiled.c:21034:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_58 [40];
decomp/Decompiled.c:21230:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/Decompiled.c:21250:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/Decompiled.c:21518:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:21553:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:21746:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [24];
decomp/Decompiled.c:21772:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_48 [40];
decomp/Decompiled.c:22191:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:22213:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:22238:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:22309:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:22331:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:22351:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:22380:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [24];
decomp/Decompiled.c:22404:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_48 [40];
decomp/Decompiled.c:22529:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:22572:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/Decompiled.c:22609:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:22655:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:22696:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:23221:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_38,auStack96 + 1,sVar3 + 1,
decomp/Decompiled.c:23260:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_38,auStack96 + 1,sVar3 + 1,
decomp/Decompiled.c:23326:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/Decompiled.c:23346:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/Decompiled.c:23368:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_18,&local_28,sVar1 + 1);
decomp/Decompiled.c:23390:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_18,&local_28,sVar1 + 1);
decomp/Decompiled.c:23488:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [16];
decomp/Decompiled.c:23512:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_48 [32];
decomp/Decompiled.c:23724:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:23742:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:24029:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:24051:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:24073:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:24103:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:24125:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:24150:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:24334:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:24356:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:24720:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:24740:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:24760:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:24801:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:24828:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:24852:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:24925:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_28,&local_68,sVar1 + 1);
decomp/Decompiled.c:24955:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_28,&local_68,sVar1 + 1);
decomp/Decompiled.c:25184:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/Decompiled.c:25204:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/Decompiled.c:25218:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [16];
decomp/Decompiled.c:25219:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:25248:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:25330:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:25356:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:25385:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:25419:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:25441:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:25463:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:25690:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [16];
decomp/Decompiled.c:25691:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:25718:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:25802:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:25826:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:25853:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:25929:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:25953:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:25975:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:26010:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,&local_58,sVar1 + 1);
decomp/Decompiled.c:26036:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,&local_58,sVar1 + 1);
decomp/Decompiled.c:26091:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:26115:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:26142:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:26283:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:26305:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:26447:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:26471:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:26498:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:26530:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:26550:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:26570:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:26615:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:26641:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:26670:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:27011:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:27033:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:27058:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:27282:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:27302:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:27463:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:27481:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:27499:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:27517:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/Decompiled.c:27552:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:27595:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/Decompiled.c:27632:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:27738:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_48,auStack112 + 1,sVar3 + 1,
decomp/Decompiled.c:27781:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_48,auStack112 + 1,sVar3 + 1,
decomp/Decompiled.c:27905:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/Decompiled.c:27925:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/Decompiled.c:28116:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/Decompiled.c:28140:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:28167:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/Decompiled.c:28228:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:28255:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:28279:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:28447:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:28484:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:28519:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:28567:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_40,auStack96 + 1,sVar3 + 1,
decomp/Decompiled.c:28606:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_40,auStack96 + 1,sVar3 + 1,
decomp/Decompiled.c:29060:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:29082:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:29104:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:29306:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:29328:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/Decompiled.c:112:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
size_t strlen(char *__s)
decomp/Decompiled.c:225:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
char * strncpy(char *__dest,char *__src,size_t __n)
decomp/Decompiled.c:1654:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:1674:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:1758:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:1778:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:1802:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:1829:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:1853:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:1892:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:1929:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:1964:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:2012:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/Decompiled.c:2051:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/Decompiled.c:2128:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:2163:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:2269:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:2270:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:2296:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:2297:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:2320:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:2321:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:2347:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:2348:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:2378:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:2379:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:2481:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:2482:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:2508:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:2509:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:2532:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:2533:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:2621:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/Decompiled.c:2622:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_18,(char *)&local_58,sVar1 + 1);
decomp/Decompiled.c:2647:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/Decompiled.c:2648:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_18,(char *)&local_58,sVar1 + 1);
decomp/Decompiled.c:2677:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:2699:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:2719:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:2720:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:2739:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:2740:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:2761:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:2783:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:2832:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:2859:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:2883:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:2986:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen((char *)&local_58);
decomp/Decompiled.c:3018:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen((char *)&local_58);
decomp/Decompiled.c:3061:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:3084:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:3117:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:3149:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:3178:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:3209:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:3210:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:3227:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:3228:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:3257:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:3261:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:3292:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:3296:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:3327:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:3331:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:3376:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:3416:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:3447:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:3488:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:3540:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/Decompiled.c:3579:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/Decompiled.c:3682:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:3711:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:3737:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:3768:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:3790:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:3812:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:3840:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:3863:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:3938:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:3965:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:4053:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:4054:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:4073:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:4074:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:4159:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:4202:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/Decompiled.c:4239:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:4271:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:4289:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:4307:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:4348:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:4524:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/Decompiled.c:4549:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/Decompiled.c:4571:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:4605:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:4689:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:4690:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_18,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:4716:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:4717:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_18,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:4758:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/Decompiled.c:4797:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/Decompiled.c:4830:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:4850:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:4925:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/Decompiled.c:4950:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/Decompiled.c:5028:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:5029:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:5048:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:5049:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:5068:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:5088:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:5177:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:5178:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:5211:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:5212:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:5254:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:5297:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:5404:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:5422:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:5473:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:5477:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/Decompiled.c:5519:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:5523:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/Decompiled.c:5561:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:5565:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/Decompiled.c:5675:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:5712:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:5747:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:5794:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:5840:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:5880:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:6085:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:6089:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:6120:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:6124:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:6155:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:6159:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:6191:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:6213:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:6235:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:6387:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:6425:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:6464:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:6465:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:6491:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:6492:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:6515:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:6516:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:6561:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:6565:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/Decompiled.c:6607:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:6611:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/Decompiled.c:6649:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:6653:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/Decompiled.c:6793:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:6842:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:6887:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:6977:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:7004:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:7028:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:7067:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_68);
decomp/Decompiled.c:7097:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_68);
decomp/Decompiled.c:7194:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:7198:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_28,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:7234:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:7238:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_28,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:7269:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:7293:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:7315:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:7342:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:7343:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:7383:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:7384:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:7492:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:7512:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:7665:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/Decompiled.c:7713:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/Decompiled.c:7779:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:7819:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:7857:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:7899:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/Decompiled.c:7925:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/Decompiled.c:7957:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:7984:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:8008:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:8112:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:8141:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:8168:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:8204:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen((char *)&local_38);
decomp/Decompiled.c:8231:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen((char *)&local_38);
decomp/Decompiled.c:8308:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:8312:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:8351:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/Decompiled.c:8355:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/Decompiled.c:8388:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:8392:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:8423:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/Decompiled.c:8448:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/Decompiled.c:8538:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:8581:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/Decompiled.c:8618:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:8650:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:8668:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:8706:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack112 + 1,
decomp/Decompiled.c:8749:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack112 + 1,
decomp/Decompiled.c:8783:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/Decompiled.c:8808:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/Decompiled.c:8839:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:8866:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:8988:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:9020:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:9049:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:9084:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:9106:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:9137:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:9160:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:9234:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:9266:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:9295:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:9404:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:9444:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:9482:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:9533:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_50 = strlen(auStack112[1],
decomp/Decompiled.c:9575:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_50 = strlen(auStack112[1],
decomp/Decompiled.c:9616:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:9645:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:9671:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:9702:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:9724:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:9746:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:9803:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:9846:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/Decompiled.c:9883:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:9975:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:10002:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:10026:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:10058:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:10085:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:10112:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:10143:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:10144:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:10161:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:10162:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:10221:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:10222:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:10255:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:10256:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:10371:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:10398:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:10432:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:10454:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:10496:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:10514:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:10532:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:10533:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:10550:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:10551:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:10580:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:10615:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:10650:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:10752:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:10770:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:10802:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:10830:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:10860:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:10861:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:10878:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:10879:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:10900:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:10924:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:10946:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:10974:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:10997:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:11025:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:11052:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:11076:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:11103:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:11121:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:11212:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:11257:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:11361:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:11395:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:11426:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:11462:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:11489:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:11516:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:11561:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:11604:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/Decompiled.c:11641:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:11779:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:11825:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:11865:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:12039:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:12066:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:12111:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:12157:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:12199:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:12243:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:12278:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:12313:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:12483:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:12484:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:12503:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:12504:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:12526:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:12553:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:12597:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:12640:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/Decompiled.c:12677:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:12722:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:12760:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:12798:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:12844:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:12879:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:13026:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:13061:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:13126:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:13127:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:13144:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:13145:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:13162:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:13163:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:13180:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:13181:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:13202:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:13203:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:13224:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:13225:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:13273:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:13307:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:13338:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:13503:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:13551:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:13695:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:13722:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:13746:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:13790:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:13830:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:13899:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:13900:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:13921:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:13922:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:13943:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:13944:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:14038:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:14087:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:14132:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:14179:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:14217:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:14255:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:14367:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:14368:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:14391:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:14392:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:14413:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:14414:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:14455:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:14501:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:14541:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:14575:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:14616:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:14737:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:14757:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:14778:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/Decompiled.c:14803:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/Decompiled.c:14838:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:14876:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:14910:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:14933:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:15029:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:15052:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:15078:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:15079:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_18,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:15100:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:15101:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_18,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:15223:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:15241:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:15263:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:15285:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:15380:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:15423:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/Decompiled.c:15460:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:15540:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:15544:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:15575:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:15579:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:15618:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:15653:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:15688:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:15720:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:15721:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:15738:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:15739:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:15950:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:15951:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:15968:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:15969:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:15986:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:16004:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:16042:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:16064:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:16086:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:16125:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:16129:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:16162:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:16166:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:16197:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:16201:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:16268:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:16297:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:16323:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:16350:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:16368:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:16386:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:16404:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:16422:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:16440:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:16460:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:16480:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:16528:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:16571:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/Decompiled.c:16608:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:16733:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:16760:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:16784:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:16811:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:16842:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:16885:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:16907:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:16991:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:17011:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:17087:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/Decompiled.c:17113:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/Decompiled.c:17151:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:17155:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:17186:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:17190:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:17221:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:17225:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:17321:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:17364:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/Decompiled.c:17401:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:17469:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:17470:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:17489:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:17490:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:17511:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:17512:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_18,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:17533:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:17534:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_18,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:17580:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:17618:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:17653:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:17687:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:17735:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/Decompiled.c:17761:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/Decompiled.c:17787:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:17805:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:17875:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:17910:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:17945:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:17978:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:18001:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:18146:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:18166:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:18235:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:18258:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:18284:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:18285:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:18308:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:18309:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:18330:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:18331:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:18417:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:18444:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:18468:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:18621:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:18625:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:18664:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/Decompiled.c:18668:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/Decompiled.c:18701:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:18705:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:18747:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:18790:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/Decompiled.c:18827:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:18859:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:18860:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:18900:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:18901:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:18966:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:18984:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:19009:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:19041:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:19070:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:19117:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/Decompiled.c:19121:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_38,auStack96 + 1,sVar3 + 1,
decomp/Decompiled.c:19156:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/Decompiled.c:19160:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_38,auStack96 + 1,sVar3 + 1,
decomp/Decompiled.c:19192:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:19221:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:19248:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:19291:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:19326:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:19361:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:19395:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:19396:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:19415:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:19416:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:19438:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:19465:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:19492:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:19524:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:19547:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:19586:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:19609:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:19664:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:19710:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:19752:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:19806:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:19835:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:19861:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:19906:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_48 = strlen(auStack96[1],
decomp/Decompiled.c:19949:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_48 = strlen(auStack96[1],
decomp/Decompiled.c:20005:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:20050:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:20082:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:20128:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:20198:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:20199:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:20216:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:20217:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:20253:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:20299:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:20341:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:20385:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:20420:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:20455:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:20503:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:20534:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:20619:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:20654:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:20689:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:20713:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:20735:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:20768:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:20769:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:20795:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:20796:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:20819:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:20820:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:20846:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:20864:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:20896:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:20939:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/Decompiled.c:20976:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:21020:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_68);
decomp/Decompiled.c:21021:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_28,(char *)&local_68,sVar1 + 1);
decomp/Decompiled.c:21050:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_68);
decomp/Decompiled.c:21051:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_28,(char *)&local_68,sVar1 + 1);
decomp/Decompiled.c:21091:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:21137:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:21177:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:21229:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:21249:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:21267:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:21301:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:21344:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:21345:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:21364:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:21365:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:21388:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:21415:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:21439:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:21466:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:21484:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:21514:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:21549:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:21613:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:21659:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:21701:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:21758:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/Decompiled.c:21759:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,(char *)&local_58,sVar1 + 1);
decomp/Decompiled.c:21784:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/Decompiled.c:21785:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,(char *)&local_58,sVar1 + 1);
decomp/Decompiled.c:21814:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:21836:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:21858:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:22024:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:22056:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:22085:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:22117:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:22153:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:22276:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:22296:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:22450:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen((char *)&local_68);
decomp/Decompiled.c:22481:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen((char *)&local_68);
decomp/Decompiled.c:22525:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:22568:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/Decompiled.c:22605:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:22654:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:22695:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:22853:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_48 = strlen(auStack112[1],
decomp/Decompiled.c:22895:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_48 = strlen(auStack112[1],
decomp/Decompiled.c:22959:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:22963:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:23002:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/Decompiled.c:23006:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/Decompiled.c:23039:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:23043:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:23071:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:23089:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:23127:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack112 + 1,
decomp/Decompiled.c:23131:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_48,auStack112 + 1,sVar3 + 1,
decomp/Decompiled.c:23170:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack112 + 1,
decomp/Decompiled.c:23174:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_48,auStack112 + 1,sVar3 + 1,
decomp/Decompiled.c:23217:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/Decompiled.c:23256:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/Decompiled.c:23325:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:23345:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:23367:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:23389:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:23408:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:23431:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:23562:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:23600:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:23638:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:23723:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:23741:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:23771:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:23775:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:23808:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:23812:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:23843:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:23847:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:23891:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/Decompiled.c:23895:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_40,auStack96 + 1,sVar3 + 1,
decomp/Decompiled.c:23930:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/Decompiled.c:23934:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_40,auStack96 + 1,sVar3 + 1,
decomp/Decompiled.c:24037:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:24038:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:24059:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:24060:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:24081:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:24082:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:24218:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:24264:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:24304:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:24342:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:24343:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:24364:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:24365:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:24391:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:24437:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:24492:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:24512:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:24566:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:24567:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:24586:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:24587:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:24609:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen((char *)&local_38);
decomp/Decompiled.c:24636:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen((char *)&local_38);
decomp/Decompiled.c:24661:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/Decompiled.c:24686:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/Decompiled.c:24800:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:24827:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:24851:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:24924:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_68);
decomp/Decompiled.c:24954:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_68);
decomp/Decompiled.c:24980:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:24998:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:25020:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:25042:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:25142:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:25163:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:25183:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:25203:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:25234:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:25235:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar2 + 1);
decomp/Decompiled.c:25257:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:25258:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:25286:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/Decompiled.c:25311:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/Decompiled.c:25341:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:25342:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar2 + 1);
decomp/Decompiled.c:25370:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:25371:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar2 + 1);
decomp/Decompiled.c:25396:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:25397:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar2 + 1);
decomp/Decompiled.c:25427:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:25428:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:25449:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:25450:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:25471:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:25472:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:25582:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:25586:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:25625:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/Decompiled.c:25629:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/Decompiled.c:25662:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:25666:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:25812:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:25813:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:25839:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:25840:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:25863:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:25864:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:25928:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:25952:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:25974:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:26009:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/Decompiled.c:26035:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/Decompiled.c:26101:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:26102:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:26128:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:26129:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:26152:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:26153:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:26291:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:26292:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:26313:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:26314:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/Decompiled.c:26341:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:26375:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:26415:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:26416:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:26433:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:26434:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/Decompiled.c:26626:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:26627:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar2 + 1);
decomp/Decompiled.c:26655:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:26656:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar2 + 1);
decomp/Decompiled.c:26681:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/Decompiled.c:26682:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar2 + 1);
decomp/Decompiled.c:26709:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:26748:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:26800:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:26832:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:26861:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/Decompiled.c:26904:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:26908:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:26939:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:26943:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:26971:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:26994:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/Decompiled.c:27107:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen((char *)&local_78);
decomp/Decompiled.c:27142:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen((char *)&local_78);
decomp/Decompiled.c:27211:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:27215:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/Decompiled.c:27256:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/Decompiled.c:27260:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/Decompiled.c:27371:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:27394:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:27415:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/Decompiled.c:27440:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/Decompiled.c:27462:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:27480:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:27498:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:27516:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/Decompiled.c:27548:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:27591:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/Decompiled.c:27628:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:27734:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack112 + 1,
decomp/Decompiled.c:27777:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack112 + 1,
decomp/Decompiled.c:27820:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:27855:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:27904:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:27924:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:27951:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_30 = strlen((char *)&local_68);
decomp/Decompiled.c:27982:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_30 = strlen((char *)&local_68);
decomp/Decompiled.c:28014:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:28015:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:28057:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:28058:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/Decompiled.c:28227:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:28254:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:28278:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:28443:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:28480:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:28515:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:28563:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/Decompiled.c:28602:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/Decompiled.c:28647:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:28651:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:28690:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/Decompiled.c:28694:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/Decompiled.c:28727:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:28731:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:28879:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:28883:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:28914:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:28918:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:28947:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:28990:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/Decompiled.c:29059:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:29081:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:29103:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:29142:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:29179:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:29214:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:29305:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:29327:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/Decompiled.c:29368:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:29414:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:29454:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/Decompiled.c:29509:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_58 = strlen(auStack128[1],
decomp/Decompiled.c:29555:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_58 = strlen(auStack128[1],
decomp/Decompiled.c:29602:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:29606:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/Decompiled.c:29645:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/Decompiled.c:29649:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/Decompiled.c:29682:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/Decompiled.c:29686:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,

ANALYSIS SUMMARY:

Hits = 1175
Lines analyzed = 30183 in approximately 1.13 seconds (26727 lines/second)
Physical Source Lines of Code (SLOC) = 24663
Hits@level = [0]  12 [1] 812 [2] 275 [3]   2 [4]  86 [5]   0
Hits@level+ = [0+] 1187 [1+] 1175 [2+] 363 [3+]  88 [4+]  86 [5+]   0
Hits/KSLOC@level+ = [0+] 48.1288 [1+] 47.6422 [2+] 14.7184 [3+] 3.5681 [4+] 3.487 [5+]   0
Minimum risk level = 1
Not every hit is necessarily a security vulnerability.
There may be other security vulnerabilities; review your code!
See 'Secure Programming HOWTO'
(https://dwheeler.com/secure-programs) for more information.
