Flawfinder version 2.0.8, (C) 2001-2017 David A. Wheeler.
Number of rules (primarily dangerous function names) in C/C++ ruleset: 223
decomp/ghidra_decompiled.c:26:  [4] (format) printf:
  If format strings can be influenced by an attacker, they can be exploited
  (CWE-134). Use a constant for the format specification.
int printf(char *__format,...)
decomp/ghidra_decompiled.c:183:  [4] (format) wprintf:
  If format strings can be influenced by an attacker, they can be exploited
  (CWE-134). Use a constant for the format specification.
int wprintf(wchar_t *__format,...)
decomp/ghidra_decompiled.c:203:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
char * strcpy(char *__dest,char *__src)
decomp/ghidra_decompiled.c:1819:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:1841:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:1861:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:2204:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:2224:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:2244:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:2788:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/ghidra_decompiled.c:2817:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/ghidra_decompiled.c:3708:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:3728:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:4084:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:4104:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:4124:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:5222:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_18,(char *)&local_48);
decomp/ghidra_decompiled.c:5247:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_18,(char *)&local_48);
decomp/ghidra_decompiled.c:5598:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/ghidra_decompiled.c:5630:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/ghidra_decompiled.c:5671:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_28);
decomp/ghidra_decompiled.c:5689:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_28);
decomp/ghidra_decompiled.c:6180:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:6205:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:6227:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:6977:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:7002:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:7024:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:8664:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/ghidra_decompiled.c:8680:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/ghidra_decompiled.c:10046:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_68_badData,(char *)&local_28);
decomp/ghidra_decompiled.c:10064:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_68_goodG2BData,
decomp/ghidra_decompiled.c:10560:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/ghidra_decompiled.c:10576:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/ghidra_decompiled.c:11006:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_28);
decomp/ghidra_decompiled.c:11024:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_28);
decomp/ghidra_decompiled.c:11063:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:11088:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:11110:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:13221:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:13241:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:14209:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_45_badData,(char *)&local_28);
decomp/ghidra_decompiled.c:14241:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_45_goodG2BData,
decomp/ghidra_decompiled.c:14374:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:14396:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:14416:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:14641:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/ghidra_decompiled.c:14657:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/ghidra_decompiled.c:14762:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_18,(char *)&local_28);
decomp/ghidra_decompiled.c:14782:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_18,(char *)&local_28);
decomp/ghidra_decompiled.c:17504:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_28);
decomp/ghidra_decompiled.c:17522:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_28);
decomp/ghidra_decompiled.c:17972:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/ghidra_decompiled.c:17988:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/ghidra_decompiled.c:21884:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:21909:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:21931:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:22004:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_20,(char *)&local_58);
decomp/ghidra_decompiled.c:22028:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_20,(char *)&local_58);
decomp/ghidra_decompiled.c:23256:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_28,(char *)&local_58);
decomp/ghidra_decompiled.c:23280:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_28,(char *)&local_58);
decomp/ghidra_decompiled.c:24031:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:24056:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:24078:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:25671:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:25692:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:26299:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:26326:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:26350:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:26379:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:26399:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:26419:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:26712:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:26737:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:26759:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:27127:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_28,(char *)&local_68);
decomp/ghidra_decompiled.c:27155:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_28,(char *)&local_68);
decomp/ghidra_decompiled.c:27298:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:27318:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:27342:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/ghidra_decompiled.c:27358:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(pcParm1,(char *)&local_18);
decomp/ghidra_decompiled.c:28133:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:28160:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:28184:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
  strcpy(local_10,(char *)&local_48);
decomp/ghidra_decompiled.c:29742:  [4] (format) printf:
  If format strings can be influenced by an attacker, they can be exploited
  (CWE-134). Use a constant for the format specification.
  printf((char *)(double)fParm1,&DAT_00431ac5);
decomp/ghidra_decompiled.c:29811:  [4] (format) printf:
  If format strings can be influenced by an attacker, they can be exploited
  (CWE-134). Use a constant for the format specification.
  printf(pcParm1,&DAT_00431ae2);
decomp/ghidra_decompiled.c:215:  [3] (random) srand:
  This function is not sufficiently random for security-related functions
  such as key and nonce creation (CWE-327). Use a more secure technique for
  acquiring random values.
void srand(uint __seed)
decomp/ghidra_decompiled.c:377:  [3] (random) srand:
  This function is not sufficiently random for security-related functions
  such as key and nonce creation (CWE-327). Use a more secure technique for
  acquiring random values.
  srand((uint)tVar1);
decomp/ghidra_decompiled.c:285:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
void * memcpy(void *__dest,void *__src,size_t __n)
decomp/ghidra_decompiled.c:1695:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:1715:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:1811:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:1833:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:1853:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:2139:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:2174:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:2196:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:2216:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:2236:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:2266:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:2290:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:2317:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:2532:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [16];
decomp/ghidra_decompiled.c:2558:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_48 [32];
decomp/ghidra_decompiled.c:2712:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:2739:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:2763:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:3160:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_28,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:3200:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_28,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:3228:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:3269:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:3700:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:3720:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:3916:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_18,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:3938:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_18,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:4076:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:4096:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:4116:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:4151:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:4169:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:4447:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [16];
decomp/ghidra_decompiled.c:4474:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [32];
decomp/ghidra_decompiled.c:5123:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:5166:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:5209:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [16];
decomp/ghidra_decompiled.c:5234:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [32];
decomp/ghidra_decompiled.c:5398:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_40,auStack96 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:5437:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_40,auStack96 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:5948:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:5972:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:5999:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:6170:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:6192:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:6217:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:6258:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_18,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:6280:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_18,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:6716:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:6734:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:6967:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:6989:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:7014:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:7553:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [24];
decomp/ghidra_decompiled.c:7579:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_48 [40];
decomp/ghidra_decompiled.c:8139:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_18,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:8166:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_18,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:8992:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar2 + 1);
decomp/ghidra_decompiled.c:9021:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar2 + 1);
decomp/ghidra_decompiled.c:9047:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar2 + 1);
decomp/ghidra_decompiled.c:9078:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:9100:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:9122:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:9182:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:9225:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/ghidra_decompiled.c:9262:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:9351:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:9378:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:9402:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:9796:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:9818:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:9911:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:9946:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:9981:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:10117:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:10135:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:10267:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:10294:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:10318:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:10457:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/ghidra_decompiled.c:10502:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/ghidra_decompiled.c:11053:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:11075:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:11100:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:11221:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/ghidra_decompiled.c:11267:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/ghidra_decompiled.c:11309:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/ghidra_decompiled.c:11353:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:11388:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:11423:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:12072:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar2 + 1);
decomp/ghidra_decompiled.c:12095:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:12287:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:12309:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:12519:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:12537:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:12750:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/ghidra_decompiled.c:12796:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/ghidra_decompiled.c:12838:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/ghidra_decompiled.c:13139:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:13161:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:13183:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:13213:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:13233:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:13761:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:13785:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:13807:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:14005:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:14025:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:14366:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:14388:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:14408:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:14532:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:14566:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:15297:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar2 + 1);
decomp/ghidra_decompiled.c:15326:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar2 + 1);
decomp/ghidra_decompiled.c:15352:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar2 + 1);
decomp/ghidra_decompiled.c:15379:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:15397:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:15415:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:15433:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:15453:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:15473:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:16079:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:16101:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:16185:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:16205:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:16979:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_18,&local_58,sVar1 + 1);
decomp/ghidra_decompiled.c:17005:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_18,&local_58,sVar1 + 1);
decomp/ghidra_decompiled.c:17124:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:17167:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/ghidra_decompiled.c:17204:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:17706:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:17730:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:17752:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:18063:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:18106:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/ghidra_decompiled.c:18143:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:18330:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:18365:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:18573:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:18597:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:18624:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:18833:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:18876:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/ghidra_decompiled.c:18913:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:19519:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:19541:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:19563:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:20121:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:20148:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:20172:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:20239:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:20270:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:20425:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:20449:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:20471:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:20493:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:20517:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:20544:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:20577:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_48 [24];
decomp/ghidra_decompiled.c:20607:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_58 [40];
decomp/ghidra_decompiled.c:20803:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:20837:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:20879:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:20899:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:21092:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:21127:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:21415:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:21433:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:21506:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:21541:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:21576:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:21874:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:21896:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:21921:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:21992:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [24];
decomp/ghidra_decompiled.c:22016:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_48 [40];
decomp/ghidra_decompiled.c:22054:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:22072:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:22177:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:22220:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/ghidra_decompiled.c:22257:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:22303:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:22344:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:22852:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_38,auStack96 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:22891:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_38,auStack96 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:22957:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:22977:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:23244:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [16];
decomp/ghidra_decompiled.c:23268:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_48 [32];
decomp/ghidra_decompiled.c:23885:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:23907:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:23929:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:24021:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:24043:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:24068:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:24252:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:24274:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:24461:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_28,&local_68,sVar1 + 1);
decomp/ghidra_decompiled.c:24491:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_28,&local_68,sVar1 + 1);
decomp/ghidra_decompiled.c:24630:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:24657:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:24681:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:25153:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:25173:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:25187:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [16];
decomp/ghidra_decompiled.c:25188:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:25217:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:25249:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:25275:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:25304:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:25338:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:25360:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:25382:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:25655:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [16];
decomp/ghidra_decompiled.c:25656:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:25683:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:25767:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:25791:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:25818:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:25894:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:25918:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:25940:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:25975:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,&local_58,sVar1 + 1);
decomp/ghidra_decompiled.c:26001:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,&local_58,sVar1 + 1);
decomp/ghidra_decompiled.c:26022:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:26046:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:26073:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:26160:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:26182:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:26288:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:26312:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:26339:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:26371:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:26391:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:26411:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:26702:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:26724:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:26749:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:27007:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:27033:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:27062:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:27111:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_48 [24];
decomp/ghidra_decompiled.c:27139:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_58 [40];
decomp/ghidra_decompiled.c:27290:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:27310:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:27471:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:27489:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:27507:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:27525:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(pvParm1,&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:27560:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:27603:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/ghidra_decompiled.c:27640:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:27746:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_48,auStack112 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:27789:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_48,auStack112 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:27913:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:27933:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:28122:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_28 [24];
decomp/ghidra_decompiled.c:28146:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:28173:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
  char local_38 [40];
decomp/ghidra_decompiled.c:28234:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:28261:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:28285:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:28453:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:28490:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:28525:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:29089:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:29111:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:29133:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:29280:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:29302:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_10,&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:29379:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:29416:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:29451:  [2] (buffer) memcpy:
  Does not check for buffer overflows when copying to destination (CWE-120).
  Make sure destination can always hold the source data.
  memcpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:112:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
size_t strlen(char *__s)
decomp/ghidra_decompiled.c:225:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
char * strncpy(char *__dest,char *__src,size_t __n)
decomp/ghidra_decompiled.c:1654:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:1674:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:1694:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:1714:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:1738:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:1765:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:1789:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:1899:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:1936:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:1971:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:2019:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/ghidra_decompiled.c:2058:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/ghidra_decompiled.c:2135:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:2170:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:2276:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:2277:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:2303:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:2304:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:2327:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:2328:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:2354:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:2355:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:2385:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:2386:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:2544:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:2545:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_18,(char *)&local_58,sVar1 + 1);
decomp/ghidra_decompiled.c:2570:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:2571:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_18,(char *)&local_58,sVar1 + 1);
decomp/ghidra_decompiled.c:2598:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:2599:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:2618:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:2619:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:2640:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:2662:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:2711:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:2738:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:2762:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:2865:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:2897:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:2940:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:2963:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:2989:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:2990:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:3007:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:3008:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:3037:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:3041:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:3072:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:3076:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:3107:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:3111:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:3156:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:3196:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:3227:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:3268:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:3320:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:3359:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:3422:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:3442:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:3502:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:3531:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:3557:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:3588:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:3610:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:3632:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:3660:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:3683:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:3758:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:3785:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:3873:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:3874:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:3893:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:3894:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:3915:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:3937:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:3969:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:4012:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:4049:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:4150:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:4168:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:4186:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:4227:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:4460:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:4461:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_18,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:4487:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:4488:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_18,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:4529:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/ghidra_decompiled.c:4568:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/ghidra_decompiled.c:4601:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:4621:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:4640:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:4663:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:4722:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:4747:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:4825:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:4826:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:4845:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:4846:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:4868:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:4897:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:4924:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:4957:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:4977:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:5045:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:5046:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:5079:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:5080:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:5122:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:5165:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:5272:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:5290:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:5394:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/ghidra_decompiled.c:5433:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/ghidra_decompiled.c:5479:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:5525:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:5565:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:5765:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:5792:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:5881:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:5919:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:5958:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:5959:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:5985:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:5986:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:6009:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:6010:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:6055:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:6059:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/ghidra_decompiled.c:6101:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:6105:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/ghidra_decompiled.c:6143:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:6147:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/ghidra_decompiled.c:6257:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:6279:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:6331:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:6380:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:6425:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:6515:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:6542:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:6566:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:6605:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_68);
decomp/ghidra_decompiled.c:6635:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_68);
decomp/ghidra_decompiled.c:6715:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:6733:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:6755:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:6779:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:6801:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:6828:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:6829:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:6869:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:6870:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:7053:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:7101:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:7162:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:7188:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:7291:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:7318:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:7384:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:7409:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:7445:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:7449:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:7488:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:7492:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/ghidra_decompiled.c:7525:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:7529:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:7565:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:7566:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,(char *)&local_58,sVar1 + 1);
decomp/ghidra_decompiled.c:7591:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:7592:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,(char *)&local_58,sVar1 + 1);
decomp/ghidra_decompiled.c:7630:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:7668:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:7704:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:7729:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:7873:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:7916:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:7953:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:8005:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack112 + 1,
decomp/ghidra_decompiled.c:8048:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack112 + 1,
decomp/ghidra_decompiled.c:8082:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:8107:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:8138:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:8165:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:8222:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:8226:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:8265:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:8269:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/ghidra_decompiled.c:8302:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:8306:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:8373:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:8405:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:8434:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:8469:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:8491:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:8573:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:8605:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:8634:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:8697:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:8698:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:8715:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:8716:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:8779:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:8819:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:8857:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:8908:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_50 = strlen(auStack112[1],
decomp/ghidra_decompiled.c:8950:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_50 = strlen(auStack112[1],
decomp/ghidra_decompiled.c:8991:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:9020:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:9046:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:9077:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:9099:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:9121:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:9178:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:9221:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:9258:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:9350:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:9377:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:9401:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:9442:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:9446:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:9485:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:9489:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/ghidra_decompiled.c:9522:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:9526:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:9559:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:9586:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:9613:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:9644:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:9645:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:9662:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:9663:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:9795:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:9817:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:9859:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:9860:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:9877:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:9878:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:9907:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:9942:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:9977:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:10116:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:10134:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:10166:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:10194:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:10224:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:10225:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:10242:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:10243:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:10266:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:10293:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:10317:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:10344:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:10362:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:10453:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:10498:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:10602:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:10636:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:10667:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:10703:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:10730:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:10757:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:10802:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:10845:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:10882:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:11145:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:11172:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:11217:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:11263:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:11305:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:11349:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:11384:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:11419:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:11589:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:11590:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:11609:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:11610:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:11632:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:11659:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:11690:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:11713:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:11748:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:11786:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:11824:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:11958:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:11993:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:12071:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:12094:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:12120:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:12121:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:12138:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:12139:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:12171:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:12217:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:12257:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:12295:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:12296:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:12317:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:12318:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:12366:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:12400:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:12431:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:12518:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:12536:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:12632:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:12680:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:12746:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:12792:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:12834:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:12943:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:12970:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:12994:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:13038:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:13078:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:13147:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:13148:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:13169:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:13170:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:13191:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:13192:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:13286:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:13335:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:13380:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:13427:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:13465:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:13503:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:13580:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:13581:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:13614:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:13615:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:13682:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:13686:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:13717:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:13721:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:13769:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:13770:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:13793:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:13794:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:13815:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:13816:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:13842:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:13883:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:14004:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:14024:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:14079:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:14104:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:14127:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:14150:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:14172:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:14173:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:14190:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:14191:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:14282:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:14305:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:14331:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:14332:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_18,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:14353:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:14354:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_18,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:14531:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:14565:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:14870:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:14888:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:14925:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:14950:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:14974:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:14975:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:15017:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:15018:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:15070:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:15092:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:15114:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:15153:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:15157:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:15190:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:15194:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:15225:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:15229:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:15296:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:15325:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:15351:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:15378:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:15396:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:15414:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:15432:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:15452:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:15472:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:15574:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:15617:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:15654:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:15723:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:15746:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:15791:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:15818:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:15842:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:15884:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:15930:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:15970:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:16004:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:16035:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:16078:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:16100:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:16184:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:16204:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:16264:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:16290:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:16328:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:16332:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:16363:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:16367:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:16398:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:16402:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:16552:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:16595:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:16632:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:16700:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:16701:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:16720:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:16721:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:16742:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:16743:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_18,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:16764:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:16765:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_18,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:16815:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:16819:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_28,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:16855:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:16859:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_28,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:16899:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:16937:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:16978:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:17004:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:17030:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:17048:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:17120:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:17163:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:17200:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:17244:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:17279:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:17314:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:17346:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:17364:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:17433:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:17434:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:17451:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:17452:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:17539:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:17573:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:17665:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:17688:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:17714:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:17715:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:17738:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:17739:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:17760:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:17761:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:18059:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:18102:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:18139:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:18171:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:18172:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:18212:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:18213:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:18278:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:18296:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:18326:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:18361:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:18399:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:18431:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:18460:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:18507:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/ghidra_decompiled.c:18511:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_38,auStack96 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:18546:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/ghidra_decompiled.c:18550:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_38,auStack96 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:18583:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:18584:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:18610:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:18611:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:18634:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:18635:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:18673:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:18708:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:18743:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:18777:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:18778:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:18797:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:18798:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:18829:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:18872:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:18909:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:18945:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:18967:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:18989:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:19017:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:19040:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:19084:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:19113:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:19139:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:19184:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_48 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:19227:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_48 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:19283:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:19328:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:19360:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:19406:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:19518:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:19540:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:19562:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:19610:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:19634:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:19656:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:19683:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:19684:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:19701:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:19702:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:19738:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:19784:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:19826:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:19870:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:19905:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:19940:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:20002:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:20045:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:20082:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:20120:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:20147:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:20171:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:20200:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:20220:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:20238:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:20269:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:20354:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:20389:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:20424:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:20448:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:20470:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:20503:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:20504:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:20530:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:20531:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:20554:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:20555:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:20593:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_68);
decomp/ghidra_decompiled.c:20594:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_28,(char *)&local_68,sVar1 + 1);
decomp/ghidra_decompiled.c:20623:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_68);
decomp/ghidra_decompiled.c:20624:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_28,(char *)&local_68,sVar1 + 1);
decomp/ghidra_decompiled.c:20664:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:20710:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:20750:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:20802:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:20836:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:20878:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:20898:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:20918:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:20919:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:20938:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:20939:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:20962:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:20989:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:21013:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:21040:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:21058:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:21088:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:21123:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:21159:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:21186:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:21213:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:21277:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:21323:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:21365:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:21414:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:21432:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:21502:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:21537:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:21572:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:21707:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:21739:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:21768:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:21800:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:21836:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:21959:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:21979:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:22053:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:22071:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:22098:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen((char *)&local_68);
decomp/ghidra_decompiled.c:22129:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_28 = strlen((char *)&local_68);
decomp/ghidra_decompiled.c:22173:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:22216:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:22253:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:22302:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:22343:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:22501:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_48 = strlen(auStack112[1],
decomp/ghidra_decompiled.c:22543:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_48 = strlen(auStack112[1],
decomp/ghidra_decompiled.c:22590:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:22594:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:22633:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:22637:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/ghidra_decompiled.c:22670:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:22674:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:22702:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:22720:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:22758:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack112 + 1,
decomp/ghidra_decompiled.c:22762:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_48,auStack112 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:22801:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack112 + 1,
decomp/ghidra_decompiled.c:22805:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_48,auStack112 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:22848:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/ghidra_decompiled.c:22887:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/ghidra_decompiled.c:22956:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:22976:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:23043:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:23047:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/ghidra_decompiled.c:23089:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:23093:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/ghidra_decompiled.c:23131:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:23135:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/ghidra_decompiled.c:23164:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:23187:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:23318:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:23356:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:23394:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:23491:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:23495:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:23528:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:23532:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:23563:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:23567:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:23611:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/ghidra_decompiled.c:23615:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_40,auStack96 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:23650:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack96 + 1,
decomp/ghidra_decompiled.c:23654:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_40,auStack96 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:23687:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:23714:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:23738:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:23825:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:23847:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:23893:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:23894:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:23915:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:23916:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:23937:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:23938:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:23969:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:23996:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:24136:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:24182:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:24222:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:24260:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:24261:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:24282:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:24283:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:24309:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:24355:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:24410:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:24430:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:24460:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_68);
decomp/ghidra_decompiled.c:24490:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_68);
decomp/ghidra_decompiled.c:24518:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:24519:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:24538:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:24539:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_28,sVar1 + 1);
decomp/ghidra_decompiled.c:24559:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:24584:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:24629:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:24656:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:24680:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:24799:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:24817:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:24835:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:24853:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:24875:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:24897:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:24991:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:24995:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:25026:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:25030:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:25061:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:25065:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:25111:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:25132:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:25152:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:25172:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:25203:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:25204:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar2 + 1);
decomp/ghidra_decompiled.c:25226:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:25227:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:25260:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:25261:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar2 + 1);
decomp/ghidra_decompiled.c:25289:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:25290:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar2 + 1);
decomp/ghidra_decompiled.c:25315:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:25316:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar2 + 1);
decomp/ghidra_decompiled.c:25346:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:25347:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:25368:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:25369:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:25390:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:25391:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:25418:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:25441:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:25547:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:25551:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:25590:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:25594:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/ghidra_decompiled.c:25627:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:25631:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:25777:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:25778:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:25804:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:25805:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:25828:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:25829:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:25893:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:25917:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:25939:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:25974:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:26000:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:26032:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:26033:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:26059:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:26060:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:26083:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:26084:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:26168:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:26169:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:26190:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:26191:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar1 + 1);
decomp/ghidra_decompiled.c:26218:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:26252:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:26446:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:26485:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_18 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:26537:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:26569:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:26598:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:26641:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:26645:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:26676:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:26680:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:26792:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:26824:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:26853:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:26931:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen((char *)&local_78);
decomp/ghidra_decompiled.c:26966:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_38 = strlen((char *)&local_78);
decomp/ghidra_decompiled.c:27018:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:27019:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar2 + 1);
decomp/ghidra_decompiled.c:27047:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:27048:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar2 + 1);
decomp/ghidra_decompiled.c:27073:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar2 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:27074:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_10,(char *)&local_48,sVar2 + 1);
decomp/ghidra_decompiled.c:27219:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:27223:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/ghidra_decompiled.c:27264:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar5 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:27268:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar5 + 1,
decomp/ghidra_decompiled.c:27379:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:27402:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:27423:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:27448:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_38);
decomp/ghidra_decompiled.c:27470:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:27488:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:27506:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:27524:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:27556:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:27599:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:27636:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:27742:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack112 + 1,
decomp/ghidra_decompiled.c:27785:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack112 + 1,
decomp/ghidra_decompiled.c:27828:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:27863:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:27912:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:27932:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:27955:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:27984:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:28011:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_20 = strlen((char *)&local_58);
decomp/ghidra_decompiled.c:28051:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_30 = strlen((char *)&local_68);
decomp/ghidra_decompiled.c:28082:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_30 = strlen((char *)&local_68);
decomp/ghidra_decompiled.c:28233:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:28260:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:28284:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:28449:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:28486:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:28521:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:28567:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:28571:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:28610:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar4 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:28614:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar4 + 1,
decomp/ghidra_decompiled.c:28647:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:28651:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_20,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:28692:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:28732:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:28770:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:28924:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:28928:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:28959:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:28963:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(local_30,auStack80 + 1,sVar3 + 1,
decomp/ghidra_decompiled.c:28992:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:29035:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_28);
decomp/ghidra_decompiled.c:29088:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:29110:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:29132:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:29171:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:29208:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:29243:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:29279:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:29301:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_48);
decomp/ghidra_decompiled.c:29327:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:29328:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:29345:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar1 = strlen((char *)&local_18);
decomp/ghidra_decompiled.c:29346:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
  strncpy(pcParm1,(char *)&local_18,sVar1 + 1);
decomp/ghidra_decompiled.c:29375:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:29412:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:29447:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  sVar3 = strlen(auStack80 + 1,
decomp/ghidra_decompiled.c:29494:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:29540:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:29580:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_40 = strlen(auStack96[1],
decomp/ghidra_decompiled.c:29635:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_58 = strlen(auStack128[1],
decomp/ghidra_decompiled.c:29681:  [1] (buffer) strlen:
  Does not handle strings that are not \0-terminated; if given one it may
  perform an over-read (it could cause a crash if unprotected) (CWE-126).
  local_58 = strlen(auStack128[1],

ANALYSIS SUMMARY:

Hits = 1175
Lines analyzed = 30183 in approximately 0.65 seconds (46440 lines/second)
Physical Source Lines of Code (SLOC) = 24663
Hits@level = [0]  12 [1] 812 [2] 275 [3]   2 [4]  86 [5]   0
Hits@level+ = [0+] 1187 [1+] 1175 [2+] 363 [3+]  88 [4+]  86 [5+]   0
Hits/KSLOC@level+ = [0+] 48.1288 [1+] 47.6422 [2+] 14.7184 [3+] 3.5681 [4+] 3.487 [5+]   0
Minimum risk level = 1
Not every hit is necessarily a security vulnerability.
There may be other security vulnerabilities; review your code!
See 'Secure Programming HOWTO'
(https://dwheeler.com/secure-programs) for more information.
